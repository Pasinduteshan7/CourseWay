pipeline {
    agent any
    
    environment {
        DOCKER_REGISTRY = "pasinduteshan"
        DOCKER_HUB_REPO_BACKEND = "${DOCKER_REGISTRY}/courseway-backend"
        DOCKER_HUB_REPO_FRONTEND = "${DOCKER_REGISTRY}/courseway-frontend"
        BUILD_NUMBER = "${env.BUILD_NUMBER}"
        EC2_HOST = "52.86.2.215"
        EC2_USER = "ubuntu"
        SSH_KEY_ID = "ec2-ssh-key"
        COMPOSE_PROJECT_NAME = "courseway"
        // Environment variables for deployment
        MONGODB_URI = "mongodb://mongo_db:27017/courseway_db"
        VITE_API_URL = "http://52.86.2.215:5000"
        CORS_ORIGINS = "http://localhost:5173,http://127.0.0.1:5173,http://52.86.2.215:5173"
    }
    
    triggers {
        // Trigger build on GitHub push
        githubPush()
    }
    
    stages {
        stage('ğŸ”„ Checkout') {
            steps {
                echo 'ğŸ“¥ Checking out code from GitHub...'
                git branch: 'main', url: 'https://github.com/Pasinduteshan7/CourseWay.git'
            }
        }
        
        stage('ğŸ”§ Build Docker Images') {
            parallel {
                stage('ğŸ—ï¸ Build Frontend') {
                    steps {
                        echo 'ğŸš€ Building frontend Docker image...'
                        script {
                            sh '''
                                cd frontend
                                docker build --no-cache -t ${DOCKER_HUB_REPO_FRONTEND}:${BUILD_NUMBER} .
                                docker tag ${DOCKER_HUB_REPO_FRONTEND}:${BUILD_NUMBER} ${DOCKER_HUB_REPO_FRONTEND}:latest
                                echo "âœ… Frontend image built successfully"
                            '''
                        }
                    }
                }
                stage('ğŸ› ï¸ Build Backend') {
                    steps {
                        echo 'ğŸš€ Building backend Docker image...'
                        script {
                            sh '''
                                cd backend
                                docker build --no-cache -t ${DOCKER_HUB_REPO_BACKEND}:${BUILD_NUMBER} .
                                docker tag ${DOCKER_HUB_REPO_BACKEND}:${BUILD_NUMBER} ${DOCKER_HUB_REPO_BACKEND}:latest
                                echo "âœ… Backend image built successfully"
                            '''
                        }
                    }
                }
            }
        }
        
        stage('ğŸ“¤ Push to Docker Hub') {
            steps {
                echo 'ğŸ“¦ Pushing images to Docker Hub...'
                withCredentials([usernamePassword(credentialsId: 'dockerhub', passwordVariable: 'DOCKER_PASS', usernameVariable: 'DOCKER_USER')]) {
                    sh '''
                        echo $DOCKER_PASS | docker login -u $DOCKER_USER --password-stdin
                        
                        echo "ğŸ“¤ Pushing versioned images..."
                        docker push ${DOCKER_HUB_REPO_FRONTEND}:${BUILD_NUMBER}
                        docker push ${DOCKER_HUB_REPO_BACKEND}:${BUILD_NUMBER}
                        
                        echo "ğŸ“¤ Pushing latest images..."
                        docker push ${DOCKER_HUB_REPO_FRONTEND}:latest
                        docker push ${DOCKER_HUB_REPO_BACKEND}:latest
                        
                        docker logout
                        echo "âœ… All images pushed to Docker Hub successfully"
                    '''
                }
            }
        }
        
        stage('ğŸš€ Deploy to AWS EC2') {
            steps {
                echo 'ğŸŒ©ï¸ Deploying application to AWS EC2...'
                withCredentials([sshUserPrivateKey(credentialsId: "${SSH_KEY_ID}", keyFileVariable: 'SSH_KEY_FILE', usernameVariable: 'SSH_USER')]) {
                    sh '''
                        # Create deployment script with proper environment variables
                        cat > deploy_to_ec2.sh << 'DEPLOY_EOF'
#!/bin/bash
set -e

echo "ğŸš€ Starting deployment on AWS EC2..."

# Ensure Docker and Docker Compose are available
if ! command -v docker &> /dev/null; then
    echo "Installing Docker..."
    curl -fsSL https://get.docker.com -o get-docker.sh
    sudo sh get-docker.sh
    sudo usermod -aG docker ubuntu
fi

if ! command -v docker-compose &> /dev/null; then
    echo "Installing Docker Compose..."
    sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
    sudo chmod +x /usr/local/bin/docker-compose
fi

# Create application directory
mkdir -p /home/ubuntu/courseway-app
cd /home/ubuntu/courseway-app

# Create updated docker-compose.yml with proper environment variables
cat > docker-compose.yml << 'COMPOSE_EOF'
version: '3.8'

services:
  mongo_db:
    image: mongo:8.2
    container_name: mongo_db
    restart: unless-stopped
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: password
    volumes:
      - mongodb_data:/data/db
    command: mongod --bind_ip_all --auth
    networks:
      - courseway

  courseway_backend:
    image: pasinduteshan/courseway-backend:latest
    container_name: courseway_backend
    restart: unless-stopped
    ports:
      - "5000:5000"
    environment:
      - MONGODB_URI=mongodb://admin:password@mongo_db:27017/courseway_db?authSource=admin
      - PORT=5000
      - JWT_SECRET=your-secret-key
      - CORS_ORIGINS=http://localhost:5173,http://127.0.0.1:5173,http://52.86.2.215:5173
    depends_on:
      - mongo_db
    networks:
      - courseway

  courseway_frontend:
    image: pasinduteshan/courseway-frontend:latest
    container_name: courseway_frontend
    restart: unless-stopped
    ports:
      - "5173:5173"
    environment:
      - VITE_API_URL=http://52.86.2.215:5000
    depends_on:
      - courseway_backend
    networks:
      - courseway

volumes:
  mongodb_data:

networks:
  courseway:
    driver: bridge
COMPOSE_EOF

# Stop existing containers
echo "ğŸ›‘ Stopping existing containers..."
docker-compose down || true

# Force remove any existing containers with our names
echo "ğŸ—‘ï¸ Removing any existing containers with our names..."
docker rm -f mongo_db courseway_backend courseway_frontend 2>/dev/null || true

# Clean up old containers and images
echo "ğŸ§¹ Cleaning up old resources..."
docker container prune -f
docker image prune -af

# Pull latest images
echo "ğŸ“¥ Pulling latest images from Docker Hub..."
docker pull pasinduteshan/courseway-frontend:latest
docker pull pasinduteshan/courseway-backend:latest
docker pull mongo:8.2

# Start new containers
echo "â–¶ï¸ Starting application services..."
docker-compose up -d

# Wait for services to be ready
echo "â³ Waiting for services to start..."
sleep 30

# Check MongoDB status and wait for it to be ready
echo "ğŸ”§ Waiting for MongoDB to be ready..."
for i in {1..30}; do
    if docker-compose exec -T mongo_db mongosh --eval "print('MongoDB is ready')" > /dev/null 2>&1; then
        echo "âœ… MongoDB is ready"
        break
    fi
    echo "â³ Waiting for MongoDB... ($i/30)"
    sleep 2
done

echo "ğŸ” Checking MongoDB authentication setup..."
# The MongoDB container is configured with MONGO_INITDB_ROOT_USERNAME and MONGO_INITDB_ROOT_PASSWORD
# These environment variables automatically create the admin user on first startup
# No additional user creation needed

echo "âœ… Deployment completed successfully!"

# Show service status
echo "ğŸ“Š Service Status:"
docker-compose ps
DEPLOY_EOF

                        # Make script executable
                        chmod +x deploy_to_ec2.sh
                        
                        # Copy deployment script to EC2
                        scp -i $SSH_KEY_FILE -o StrictHostKeyChecking=no deploy_to_ec2.sh ${EC2_USER}@${EC2_HOST}:/tmp/
                        
                        # Execute deployment on EC2
                        ssh -i $SSH_KEY_FILE -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} 'bash /tmp/deploy_to_ec2.sh'
                        
                        echo "âœ… Application deployed successfully to EC2!"
                    '''
                }
            }
        }
        
        stage('ğŸ” Health Check & Verification') {
            steps {
                echo 'ğŸ¥ Performing comprehensive health checks...'
                withCredentials([sshUserPrivateKey(credentialsId: "${SSH_KEY_ID}", keyFileVariable: 'SSH_KEY_FILE', usernameVariable: 'SSH_USER')]) {
                    sh '''
                        # Create health check script
                        cat > health_check.sh << 'HEALTH_EOF'
#!/bin/bash

echo "ğŸ” Performing health checks..."

cd /home/ubuntu/courseway-app

# Check container status
echo "=== Container Status ==="
docker-compose ps

echo ""
echo "=== Service Health Checks ==="

# Check MongoDB
echo "Checking MongoDB connection..."
max_attempts=5
attempt=1
while [ $attempt -le $max_attempts ]; do
    if docker-compose exec -T mongo_db mongosh admin --eval "db.runCommand({ping: 1})" > /dev/null 2>&1; then
        echo "âœ… MongoDB is healthy"
        break
    else
        echo "â³ MongoDB not ready, attempt $attempt/$max_attempts"
        if [ $attempt -eq $max_attempts ]; then
            echo "âŒ MongoDB health check failed"
        fi
    fi
    attempt=$((attempt + 1))
    sleep 5
done

# Check Backend API with retry
echo "Checking Backend API..."
max_attempts=10
attempt=1
backend_healthy=false
while [ $attempt -le $max_attempts ]; do
    if curl -f --connect-timeout 5 --max-time 10 http://localhost:5000 > /dev/null 2>&1; then
        echo "âœ… Backend API is healthy"
        backend_healthy=true
        break
    else
        echo "â³ Backend not ready, attempt $attempt/$max_attempts"
        if [ $attempt -eq $max_attempts ]; then
            echo "âŒ Backend API health check failed"
            echo "Backend logs:"
            docker-compose logs --tail=10 courseway_backend
        fi
    fi
    attempt=$((attempt + 1))
    sleep 5
done

# Check Frontend with retry
echo "Checking Frontend..."
max_attempts=5
attempt=1
while [ $attempt -le $max_attempts ]; do
    if curl -f --connect-timeout 5 --max-time 10 http://localhost:5173 > /dev/null 2>&1; then
        echo "âœ… Frontend is healthy"
        break
    else
        echo "â³ Frontend not ready, attempt $attempt/$max_attempts"
        if [ $attempt -eq $max_attempts ]; then
            echo "âŒ Frontend health check failed"
            echo "Frontend logs:"
            docker-compose logs --tail=10 courseway_frontend
        fi
    fi
    attempt=$((attempt + 1))
    sleep 5
done

echo ""
echo "=== Network Connectivity ==="
echo "Testing external access..."
curl -I http://52.86.2.215:5173 2>/dev/null | head -1 || echo "âš ï¸ External frontend access check failed"
curl -I http://52.86.2.215:5000 2>/dev/null | head -1 || echo "âš ï¸ External backend access check failed"

echo ""
echo "=== Application URLs ==="
echo "ğŸŒ Frontend: http://52.86.2.215:5173"
echo "ğŸ”— Backend API: http://52.86.2.215:5000"
echo "ğŸ“Š Database: MongoDB on localhost:27017"

echo ""
echo "=== Deployment Summary ==="
echo "ğŸ“¦ Build Number: ${BUILD_NUMBER:-unknown}"
echo "ğŸ·ï¸ Frontend Image: pasinduteshan/courseway-frontend:latest"
echo "ğŸ·ï¸ Backend Image: pasinduteshan/courseway-backend:latest"
echo "â° Deployment Time: $(date)"
echo "âœ… Status: DEPLOYED"

echo ""
echo "=== Container Resource Usage ==="
docker stats --no-stream --format "table {{.Container}}\\t{{.CPUPerc}}\\t{{.MemUsage}}\\t{{.NetIO}}"
HEALTH_EOF

                        # Execute health check on EC2
                        ssh -i $SSH_KEY_FILE -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} 'bash -s' < health_check.sh
                        
                        echo ""
                        echo "ğŸ‰ Health checks completed!"
                        echo "ğŸŒ Your application should be accessible at: http://52.86.2.215:5173"
                    '''
                }
            }
        }
    }
    
    post {
        always {
            echo 'ğŸ§¹ Cleaning up local resources...'
            sh '''
                docker logout || true
                docker system prune -f || true
                rm -f deploy_to_ec2.sh health_check.sh
            '''
        }
        
        success {
            echo '''
            ğŸ‰ ========================================
               DEPLOYMENT SUCCESSFUL! âœ…
            ========================================
            
            âœ… Docker images built and pushed to Docker Hub
            âœ… Application deployed to AWS EC2 (52.86.2.215)
            âœ… Health checks completed
            
            ğŸŒ Your CourseWay application is now live at:
            ğŸ“± Frontend: http://52.86.2.215:5173
            ğŸ”— Backend API: http://52.86.2.215:5000
            
            ğŸ“ What happens next:
            1. Test your application functionality
            2. Make code changes and push to GitHub
            3. Jenkins will automatically build and deploy
            4. Monitor logs if any issues occur
            
            ğŸš€ Happy coding!
            '''
        }
        
        failure {
            echo '''
            âŒ ========================================
               DEPLOYMENT FAILED! ğŸš¨
            ========================================
            
            Please check the console output above for detailed error information.
            
            Common troubleshooting steps:
            ğŸ”§ Docker Hub credentials: Manage Jenkins â†’ Credentials â†’ dockerhub-credentials
            ğŸ”§ SSH key configuration: Manage Jenkins â†’ Credentials â†’ ec2-ssh-key
            ğŸ”§ Application logs: SSH to EC2 and run docker-compose logs
            
            ğŸ“ Need help? Check the Jenkins logs and container output above.
            '''
        }
        
        unstable {
            echo 'âš ï¸ Pipeline completed with warnings. Some health checks may have failed.'
        }
    }
}